### 表示方式 二值信号

现代计算机存储和处理的信息以二值信号表示。

```
这属于命题知识，就像 二是偶数一样。
就像，python表示变量的方式，不需要在前面增加 var。一样。
这句话不需要理解，只需要记住就可以了。
```



### 二进制数字的威力

这些微不足道的二进制数字，或者称 为位(bit), 形成了数字革命的基础。

### 二进制的起源与发展

大家熟悉并使用了 1000 多年的十进制（以 10 为基数） 起源于印度，在 12 世纪被阿拉伯数学家改进，并在 13 世纪被意大利数学家 Leonardo Pisano(大约公元 1170— 1250, 更为大家所熟知的名字是 Fibonacci)带到西方。

### 为什么二进制的表示方式更适合计算机

对于有 10' 个手指的人类来说，使用十进制表示法是很自然的事情，但是当构造存储和处理信息的机 器时，二进制值工作得更好。

### 理由如下

1. 二值信号能够很容易地被表示、存储和传输。

例如  	可以表 示为穿孔卡片上有洞或无洞、导线上的高电压或低电压。

​			  或者顺时针或逆时针的磁场。



对 二值信号进行存储和执行计算的**电子电路**非常简单和可靠，制造商能够在一个单独的硅片 上集成数百万甚至数十亿个这样的电路。 



### 本章的主要内容

孤立地讲，单个的位不是非常有用。然而，当把位组合在一起，再加上某种解释(inter¬ pretation), 即赋予不同的可能位模式以含意，我们就能够表示任何有限集合的元素。比 如，使用一个二进制数字系统，我们能够用位组来编码非负数。通过使用标准的**字符码**， 我们能够对文档中的字母和符号进行编码。在本章中，我们将讨论这两种**编码**，以及**负数表示**和**实数近似值**的编码。 

```
四种编码方式
```





## 三种数字表示

### 1. 无符号

无符号（unsigned)编码基于传统的二进制表示法， 表示大于或者等于零的数字。

### 2. 补码

补码（two’s-complement)编码是表示有符号整数的最常见的 方式，有符号整数就是可以为正或者为负的数字。

### 3. 浮点数

浮点数（floating-point)编码是表示实数 的科学记数法的以 2 为基数的版本。计算机用这些不同的表示方法实现算术运算，例如加 法和乘法，类似于对应的整数和实数运算。



 计算机的表示法是用有限数量的位来对一个数字编码，因此，当结果太大以至不能表 示时，某些运算就会溢出（overflow)。溢出会导致某些令人吃惊的后果。例如，在今天的 大多数计算机上(使用 32 位来表示数据类型 int)�计算表达式 200*300*400*500 会得出结果 884 901 888。这违背了整数运算的特性，计算一组正数的乘积不应产生一个负的结果。









### 值的范围和不同算术运算的属 性

通过研究数字的实际表示，我们能够了解可以表示的值的范围和不同算术运算的属 性。



### 了解这种属性的重要性

为了使编写的程序能在全部数值范围内正确工作，而且具有可以跨越不同机器、操作 系统和编译器组合的可移植性，了解这种属性是非常重要的。



后面我们会讲到，大量计算 机的安全漏洞都是由于**计算机算术运算**的微妙细节引发的。在早期，当人们碰巧触发了程 序漏洞，只会给人们带来一些不便，但是现在，有众多的黑客企图利用他们能找到的任何 漏洞，不经过授权就进入他人的系统。这就要求程序员有更多的责任和义务，去了解他们 的程序如何工作，以及如何被迫产生不良的行为。 

### 命题知识 

计算机用几种不同的二进制表示形式来编码数值。



随着第 3 章进入机器级编程，你需 要熟悉这些表示方式。



### 本章主要内容

在本章中，我们描述这些编码，并且教你如何推出数字的表示。 通过直接操作数字的位级表示，我们得到了几种进行算术运算的方式。理解这些技术对 于理解编译器产生的机器级代码是很重要的，编译器会试图优化算术表达式求值的性能。 

### 两个部分 基本定义到 属性的讲解

我们对这部分内容的处理是基于一组核心的数学原理的。从编码的基本定义开始，然 后得出一些属性，例如可表示的数字的范围、它们的位级表示以及算术运算的属性。

### 重要观念 

我们 相信从这样一个抽象的观点来分析这些内容，对你来说是很重要的，因为程序员需要对计 算机运算与更为人熟悉的整数和实数运算之间的关系有清晰的理解。









## 如何阅读本章

本章我们研究在计算机上如何表示数字和其他形式数据的基本属性，以及计算机对 这些数据执行操作的属性。这就要求我们深入研究数学语言，编写公式和方程式，以及 展示重要属性的推导。 为 了帮助你阗读，这部分内容安排如下：首先给出以数学形式表示的属性，作为原 理。然后，用例子和非形式化的讨论来解释这个原理。



我们建议你反复阅读**原理描述**和 它的**示例与讨论**，直到你对该属性的说明内容及其重要性有了**牢固的直觉**。对于更加复 杂的属性，还会提供推导，其结构看上去将会像一个数学证明。虽 然最终你应该尝试理 解这些推导，但在第一次阅读时你可以跳过它们。



 我们也鼓励你在阅读正文的过程中完成练习题，这会促使你主动学习，帮助你理论联 系实际。有了这些例题和练习题作为背景知识，再返回推导，你将发现理解起来会容易许 多。同时，请放心，掌握好高中代数知识的人都具备理解这些内容所需要的数学技能









## 2 16 10进制之间的 人工转换

一个简单的窍门是，记住十六进制 数字 **A** C 和 **F** 相应的十进制值。

A 10

C 12

F 15

而对于把十六进制值 B D 和 E 转换成十进制值，则可 以通过计算它们与前三个值的相对关系来完成

B 11

D 13

E 14











3 9 A 7 F 8 

11 1001 1010 0111  1111 1000



### 练习题

1100 1001 0111 1011



0











# 2.1.2 字数据大小



## 字长的作用

每台计算机都有一个字长（word size), 指明指针数据的标称大小(nominal size) 

## 字长的大小决定虚拟地址空间的最大值

因为 虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是虚拟地址空 间的最大大小。也就是说，对于一个字长为 w位(32位，64位)的机器而言，虚拟地址的范围为 0 2—1， 程序最多访问 P 个字节。





## 向后兼容性

大多数 64 位机器也可以运行为 32 位机器编译的程序，这是一种向后兼容。



## 32位程序与64位程序之间的区别

区别在于该程序是如何编译的， 而不是其运行的机器类型。







## 各种数值类型的区别在于编码方式不同

计算机和编译器支持多种不同方式编码的数字格式，如不同长度的整数和浮点 数。

## 疑惑

比如，许多机器都有处理单个字节的 指令，也有处理表示为 2 字节、4 字节或 者 8 字节整数的指令，还有些指令支持表 示为 4 字节和 8 字节的浮点数

```
字节是一种值，他就是文本字符。
他是用一个唯一整数所表示的。不记得了吗
```



## 数据类型与字节数之间的关系

C 语言支持整数和浮点数的多种数据 格式。图 2-3 展示了为 C 语言各种数据类型分配的字节数。

每种数据类型所分配的字节数是不相同的，字节数大所反映的就是，占用空间





## 可移植性

程序员应该力图使他们的程序在不同的机器和编译器上可移植。

可移植性的一个方面就 是使程序对**不同数据类型的确切大小**不敏感。



C 语言标准对不同数据类型的数字范围设置了 下界(这点在后面还将讲到）， 但是却没有上界。

## 从64位机器移植带来的问题

因为从 1980 年左右到 2010 年左右，32 位机 器和 32 位程序是主流的组合，许多程序的编写都假设为图 2-3 中 32 位程序的字节分配。随 着 64 位机器的日益普及，在将这些程序移植到新机器上时，许多隐藏的对字长的依赖性就 会显现出来，成为错误。

### 1. 例子

比如，许多程序员假设一个声明为 int 类型的程序对象能被用来存储 一个指针。这在大多数 32 位的机器上能正常工作，但是在一台 64 位的机器上却会导致问题。



## 重要概念

```
字长  64位 32位
虚拟地址 虚拟空间
编码
数据类型 数值类型  
数字格式 浮点数 整数 双精度浮点 单精度浮点
指针 指针数据大小
可移植性
字节
关键字
编码 
```

## 疑问



## 问题

### 1. 为什么64位能运行的程序在32位就不能运行了呢

我如果要跟别人讲清楚，首先它需要知道什么是字长。它指明了(支持多大的程序范围)所以字长决定的最重要的系统参数就是虚拟地址空 间的最大大小。32位只支持，xx。而64位支持 2 * 11 的字节。

我们写程序，程序中的各种数据类型，都是有相应的字节大小的。在两种机器中，用c声明的各种数据类型，所表示的字节数量是不相同的，比如。float类型，在64位中表示 八位。而在32位中只表示4位。当我们把一个在64位写好的程序，放到32位机器上跑时，因为两种字节数不匹配，所以就会导致超过虚拟空间的这么一种情况。

